{
  'data': {
    'id': 79485321,
    'slug': 'bg3cg1',
    'title': '6月份工作计划与总结',
    'book_id': 627404,
    'book': {
      'id': 627404,
      'type': 'Book',
      'slug': 'cwfdgn',
      'name': '工作/周报',
      'user_id': 671301,
      'description': '记录工作',
      'creator_id': 671301,
      'public': 0,
      'items_count': 27,
      'likes_count': 0,
      'watches_count': 1,
      'content_updated_at': '2022-06-26T16:17:30.856Z',
      'updated_at': '2022-06-26T16:17:31.000Z',
      'created_at': '2019-12-16T04:17:01.000Z',
      'user': None,
      '_serializer': 'v2.book'
    },
    'user_id': 671301,
    'user': {
      'id': 671301,
      'type': 'User',
      'login': 'sunhanwu',
      'name': 'sunhanwu',
      'description': 'Talk is cheap, show me the code',
      'avatar_url': 'https://cdn.nlark.com/yuque/0/2019/png/671301/1576395655977-avatar/ad9d6d18-5e72-4b8d-8bdc-845e2f1e84d1.png',
      'books_count': 20,
      'public_books_count': 2,
      'followers_count': 1,
      'following_count': 0,
      'created_at': '2019-12-15T07:34:47.000Z',
      'updated_at': '2022-06-26T13:35:46.000Z',
      '_serializer': 'v2.user'
    },
    'format': 'lake',
    'body': '- 6月5日工作计划\n- [x] 下午：sjr课程完成\n- [ ] 下午：完成3-5道leetcode题，继续二分法未完成\n- [ ] 晚上：调研现有的工作未完成\n\n总结：基本一天没有怎么学习。除了下午学习了一点vue和nodejs的知识外，没有学太多的东西。调研工作没有开展，另外leetcode题并没有开始刷。从明天开始要认真学习。另外，多多少少需要继续完成apphub的编写，keep learning\n\n- 6月6日工作计划\n- [x] 下午：搭建登录页面完成\n- [ ] ~~晚上：刷题~~未完成\n- [ ] ~~晚上：科研工作~~未完成\n- 6月9日工作计划\n- [ ] 下午：开始准备大规模评估对抗样本\n- [ ] 调研数据集\n- [ ] 调研特征集，特征提取器\n         - CIC-Flowmeter\n- [ ] 调研目标模型\n- [ ] 调研攻击方法\n- [ ] 晚上：继续下午的工作，另外刷题别忘了\n\n---\n\n- 6月21日工作计划\n- [x] 上午: 刷题(5-10道题)完成\n      - 3无重复字符的最长子串：滑动串口方法华为medium\n      - 739[每日温度](https://leetcode-cn.com/problems/daily-temperatures)： 华为medium\n         - 暴力破解：使用两个循环往后搜索第一个超过当前温度的日期，算法复杂度为![](https://cdn.nlark.com/yuque/__latex/b67c3aca1bcc34aec861fef4fbf09535.svg#card=math&code=n%5E2&id=yZhEh) 超时\n         - 单调栈：单调栈在普通栈的基础上，限制栈内元素必须有序，按照某种特性(元素的值或者其他属性)单调递增或者单调递减。那么这个题就可以使用单调栈来解决。从前往后遍历每个温度，如果栈不为空并且当前文档大于栈顶那天的温度，说明找到了第一个大于栈顶温度的那边。那么栈顶那天的升温天数为遍历index减去栈顶索引。这个步骤一直进行下去到栈为空，再把当前天压入栈。如果当前温度小于或等于栈顶温度，那么直接压入栈。所以这个里面单调栈中存储的是还没有找到升温天数的索引。AC\n      - 42接雨水: hard\n         - 暴力破解：从左往右遍历每个柱子(第一个O(n))，对于每个柱子，找到他左边最高的柱子，l和右边最高的柱子r。这样当前柱子接雨水的量为min(l, r) - cur。在找左右最高的时候又经历了一个O(n)，所以算法复杂度为O(![](https://cdn.nlark.com/yuque/__latex/b67c3aca1bcc34aec861fef4fbf09535.svg#card=math&code=n%5E2&id=lmO5K))。超时\n         - 单调栈：维护一个单调递减栈，用于存储还没有计算能存储多少雨水的柱子。当新的柱子高度小于栈顶的时候或者栈为空的时候，直接入栈。否则弹出栈顶元素cur，然后比较取柱子高度height[i]和新的栈顶柱子高度height[stack[-1]]的较小值，减去height[cur]的高度就是cur这次存储雨水的高度。然后用i减去stack[-1]再减一就是存储雨水的宽度。高度乘以宽度就是cur柱子存储雨水的量。累加到result里面即可，整体算法复杂度为![](https://cdn.nlark.com/yuque/__latex/e65a67ac353abeeff44c359310d05c02.svg#card=math&code=O%28n%29&id=O2ftM)。AC\n```python\nclass Solution:\n    """\n    这个题要注意是先出栈，然后\n    """\n    def trap(self, height: List[int]) -> int:\n        result = 0\n        stack = []\n        for i in range(len(height)):\n            while len(stack) > 0 and height[i] > height[stack[-1]]:\n                cur = stack[-1]\n                stack = stack[:-1]\n                if len(stack) == 0:\n                    break\n                result += (min(height[stack[-1]], height[i]) - height[cur]) * (i - stack[-1] - 1)\n            stack.append(i)\n        return result\n```\n\n      - 84柱状图中最大的矩形hard\n         - 暴力破解：从左往右遍历所柱形，对于每个柱子，往左和往右找到不小于该柱子高度的左右边界l和r，然后(r - l) * height[i]就是当前柱子能找到的最大矩形面积。算法复杂度是![](https://cdn.nlark.com/yuque/__latex/c120209360617f2e6d2db673c7053248.svg#card=math&code=O%28n%29%5E2&id=PnZuH)超时\n         - 单调栈：同暴力破解。对于每个柱子还是需要找到左右边界。但是使用一个单调递增栈存储还没有找到右边界的柱子。从左往右遍历所有柱子的时候，当单调栈为空或者当前柱子大于栈顶柱子的高度的时候直接入栈。否则弹出栈顶柱子h。计算以h为高度的矩形的最大面积。左边界就是弹出之后的栈顶柱子的索引，右边界就是此时的i，所以宽度为i - stack[-1] - 1, 高度为heights[h], 得到矩形面积后如果大于res则更新resAC\n```python\nclass Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        heights = [0] + heights + [0]\n        stack = []\n        res = 0\n        for i in range(len(heights)):\n            while len(stack) > 0 and heights[i] < heights[stack[-1]]:\n                # print(stack)\n                h = stack.pop()\n                res = max(heights[h] * (i - stack[-1] - 1), res)\n            stack.append(i)\n        return res        \n```\n\n      - 496. 下一个更大元素 Ieasy\n         - 暴力破解：直接两个循环找到num2的下一个更大元素列表。复杂度![](https://cdn.nlark.com/yuque/__latex/f2d5f588234eb61a559ff90c41511b85.svg#card=math&code=O%28n%5E2%29&id=d3jvn)\n         - 单调递减栈：维护一个单调递减栈，用于记录还没有找到下一个更大元素的数。当有元素大于栈顶元素，更新栈顶元素的下一个更大元素位置数组。AC\n```python\nclass Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        nextBig = [-1] * len(nums2)\n        stack = []\n        for i in range(len(nums2)):\n            while len(stack) > 0 and nums2[i] > nums2[stack[-1]]:\n                nextBig[stack[-1]] = nums2[i]\n                stack.pop()\n            stack.append(i)\n        result = [nextBig[nums2.index(x)] for x in nums1 ]\n        return result\n```\n\n- [ ] 下午：~~整理面试的相关资料~~未完成\n- [x] 晚上：开始做实验，基础对抗性评估。从准备数据集和目标模型开始准备部分完成\n      - 准备好KDD_feature_extractor工具\n      - 准备好CICFlowMeter工具用于提取特征\n\n- 6月22日工作计划\n- [x] 上午：找到CICFlowMeter工具的bug并修复完成\n      - ./gradlew distZip官方给的代码之后需要修改生成build文件中的cfm脚本\n```python\nDEFAULT_JVM_OPTS=\'"-Djava.library.path=/home/sunhanwu/tools/CICFlowMeter/jnetpcap/linux/jnetpcap-1.4.r1425/"\'\n```\n\n- [ ] 下午：刷题5-10道华为完成\n      - 15[三数之和](https://leetcode-cn.com/problems/3sum)华为medium\n         - 暴力破解：首先需要给nums排序，用python内置的排序函数，复杂度在![](https://cdn.nlark.com/yuque/__latex/87ca12656f09824e20f4d5cf4c7d126a.svg#card=math&code=O%28log%28n%29%29&id=eOd0d)。然后从左往右遍历nums，对于nums[i], 如果大于0,直接返回。l=i+1，r=n-1,如果nums[i] + nums[l] + nums[r] == 0, 加入到结果列表中，并l ++, r--.(注意结果的去重，可以将列表字符串化进行去重)。如果nums[i] + nums[l] + nums[r]  > 0, r--; 否则 l++AC\n      - [554砖墙](https://leetcode-cn.com/problems/brick-wall) 华为medium\n         - 暴力破解：转换一下思路，找穿过砖块最少的线相当于找空隙最多的线。所以找里面空隙最多的地方划线即可。所以遍历整个wall，找到每行的空隙。然后将空隙出现的次数存储在字典中。最后找到空隙最多的那个。如果字典中没有值的话直接返回len(wall), 否则返回len(wall)减去最多的空隙的个数AC\n      -  medium\n         - 暴力破解：首先按照每个区间的左边界为key对所有区间进行排序。然后循环遍历所有区间。比较当前区间的左边界和上一个区间的右边界。如果当前区间的左边界大于上一个区间的右边界，则不用合并，直接加入到区间中。如果当前区间的左边界小于等于上一个区间的右边界，则需要合并当前区间和上一个区间。注意合并后的区间左边界肯定是上一个区间的左边界，但是右边界是当前区间的右边界和上一个区间的右边界的较大值(需要用max函数取一下较大值)。AC\n      - [53最大子序和](https://leetcode-cn.com/problems/maximum-subarray)华为easy\n         - 贪心解法：初始化res为空列表。遍历数组，如果res的和小于0，则清空res，每次遍历都将nums[i]加入到res中。然后在对比maxNum是否有变化，如果最大值变化了就更新。需要注意的是res只是为了方便理解。实际操作的时候世界用个变量累计和就可以。不然的话sum求和的话会导致复杂度升级为![](https://cdn.nlark.com/yuque/__latex/f2d5f588234eb61a559ff90c41511b85.svg#card=math&code=O%28n%5E2%29&id=zldIr)AC\n      - [20有效的括号](https://leetcode-cn.com/problems/valid-parentheses)华为easy\n         - 简单的使用栈进行匹配AC\n- [ ] 晚上：开始准备跑实验，处理MTA，CIC的三个数据集的数据为KDD特征集和CICFlowMeter特征集，注意打标签未完成\n      - kdd_features:\n- [ ] baseline: KDD99\n- [ ] MTA\n- [ ] CIC\n- [ ] CTU\n      - cicflowmeter_features:\n- [ ] MTA\n- [ ] CIC\n- [ ] CTU\n> 算法题大概完成了5道，但是基本每道题都是查看了解答的。虽然也学到了不少的东西。感觉是目前还是题目刷少了，很多东西想不过来。另外实验部分感觉效率太低。一晚上没有写完一个特征提取模块。\n> \n\n\n---\n\n- 6月23日\n- [ ] 下午：算法题未完成\n      - [5最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring)华为medium\n         -  暴力解法: 首先外部两层循环用于确定子串的左右边界。再一层循环用于判断子串是否是回文串。算法复杂度为![](https://cdn.nlark.com/yuque/__latex/a77815a52a2d0050828079fb142b1410.svg#card=math&code=O%28n%5E3%29&id=VKw30)超时(1000个用例长度一般要求复杂度在![](https://cdn.nlark.com/yuque/__latex/f2d5f588234eb61a559ff90c41511b85.svg#card=math&code=O%28n%5E2%29&id=j3Zdy)）其实如果用java或者c写的话暴力应该能过。\n         - 动态规划：还没有成功实现。部分完成\n      - <br />\n      - <br />\n- [ ] 晚上：~~实验部分~~未完成\n- [ ] options：~~看一篇论文，或者看几个算法视频~~\n> 总结：下午开始做最长回文子串，但是目前没有AC，DP的转态转移方程大概能够理解，但是有些细节问题没有想清楚，导致一直有测试样例没有通过。下午帮帮解决了Pcap++和tstat的问题，发现tstat也提供了一个不错的特征集。另外第一次知道了flowcontainer，有空的话可以仔细了解一下。但是目前的重点还是刷题，学位论文的实验暂缓一下。\n\n\n---\n\n- 6月24日\n- [ ] 上下午：继续刷算法题(动态规划专题)标签\n      - [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring)华为medium\n         - 动态规划：看s[i:j]是否是回文字符串，如果s[i] == s[j] 并且s[i+1:j-1]也是回文字符串的话，s[i:j]就是回文字符串。所有单个字符都是回文字符串，两个一样的字符串也是回文字符串。这样三个以上字符串就可以从简单的较短的字符串推导而来。算法复杂度为O(n)。注意状态转移的时候要先计算长度短的回文字符串，所以循环遍历的时候要遍历长度。而不是回文字符串的左右边界。AC\n      - [227. 基本计算器 II](https://leetcode-cn.com/problems/basic-calculator-ii)华为medium\n         - 使用栈：O(n)一个循环，注意+直接入栈，-将对应的数字的相反数入栈，乘除法需要取出栈顶的元素进行乘除操作之后再入栈。另外注意python中-3//2 = -2，整除去向下取整的。AC\n      - [316. 去除重复字母](https://leetcode-cn.com/problems/remove-duplicate-letters)华为medium\n         - 单调栈：设置一个升序单调栈，当有字符不满足升序的时候。如果后面的字符串中还有栈顶字符，就弹出栈顶。知道栈顶没有出现在后续字符中就压入当前字符入栈。AC\n      - [735. 行星碰撞](https://leetcode-cn.com/problems/asteroid-collision)华为medium\n         - 栈：逻辑判断稍微有点多，需要仔细判断AC\n      - [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix)华为medium\n         - 直接暴力的方法。O(mn)AC\n      - [剑指 Offer 10- II. 青蛙跳台](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof)华为easy\n         - 动态规划，简单题AC\n      - [820. 单词的压缩编码](https://leetcode-cn.com/problems/short-encoding-of-words)\n         - 暴力解法：第一层循环用来遍历单词，里面再有一层循环用来检查之后是否有更合适的单词AC\n      - [46. 全排列](https://leetcode-cn.com/problems/permutations)华为medium\n         - 使用递归，一遍过AC\n      - [1004. 最大连续1的个数 III](https://leetcode-cn.com/problems/max-consecutive-ones-iii)\n         - 暴力破解：理论上的算法复杂度在O(nk!)，并且比较难实现。没有具体去实现\n         - 滑动窗口：抓住一个条件就是滑动窗口内的0不允许超过k个，一旦超过就减小窗口。这样的算法复杂度在O(n)AC\n      - [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists)\n         - 直接O(m+n)暴力求解\n- [ ] 晚上：做实验未完成\n      - 简单的整理了一些数据集和特征集\n:::info\nPS：刷算法题的时候，写完之后除了测试题目提供的几个测试样例，自己也要多测试几个测试样例\n:::\n\n---\n\n- 6月25日\n- [ ] 上午：算法题标签\n      - [994. 腐烂的橘子](https://leetcode-cn.com/problems/rotting-oranges)华为medium\n         - 直接暴力破解：AC\n      - [93. 复原IP地址](https://leetcode-cn.com/problems/restore-ip-addresses) 华为medium\n         - 动态规划：注意出口条件，需要注意加一个控制分割点的参数kAC\n      - [315. 计算右侧小于当前元](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self)未完成\n         - 暴力解法：![](https://cdn.nlark.com/yuque/__latex/f2d5f588234eb61a559ff90c41511b85.svg#card=math&code=O%28n%5E2%29&id=Z7Wbm)超时\n      - [剑指Offer51：数组中的逆序对](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)未完成\n         - <br />\n      - dasjk\n- [ ] 下午：~~算法题~~未完成\n- [ ] 晚上：~~实验~~未完成\n> 腐烂的桔子类似之前螺旋找数一样，没有太深的技巧。然后复原IP地址类似之前的全排列，用递归做，但是注意出口条件就可以了。另外变天大部分时间都没啥效率，在等论文结果。\n\n\n---\n\n- 6月26日\n\n- [ ] 下午：~~整理简历~~未完成\n      - [<br />](https://www.yuque.com/sunhanwu/cwfdgn/yr4wro#nRw73)\n- [ ] 晚上：~~继续整理简历，有空余时间把周六没有完成的两道题做完~~未完成\n> 摆烂的一天\n\n\n---\n\n- 6月27日\n- [ ] 上午：leetcode刷题标签\n- [ ] 下午：完成个人简历中英文版本标签\n- [ ] 晚上：开始考虑投递个人简历标签\n> 初步确定找安全算法方向的工作(类似风控，云安全算法这种)，就硬卷\n\n\ndsa\n<a name="XikjS"></a>\n### todo:\n\n- [ ] 把个人博客给搭建起来，哪怕需要备案，方便做简历\n- [ ] 抽空是几个工作找的不错的师兄们聊聊找工作的事情\n- [ ] 7月之前如果论文中了的话抽一天时间把简历做了\n- [ ] flowcontainer使用\n- [ ] tstat使用\n\n',
    'body_draft': '- 6月5日工作计划\n- [x] 下午：sjr课程完成\n- [ ] 下午：完成3-5道leetcode题，继续二分法未完成\n- [ ] 晚上：调研现有的工作未完成\n\n总结：基本一天没有怎么学习。除了下午学习了一点vue和nodejs的知识外，没有学太多的东西。调研工作没有开展，另外leetcode题并没有开始刷。从明天开始要认真学习。另外，多多少少需要继续完成apphub的编写，keep learning\n\n- 6月6日工作计划\n- [x] 下午：搭建登录页面完成\n- [ ] ~~晚上：刷题~~未完成\n- [ ] ~~晚上：科研工作~~未完成\n- 6月9日工作计划\n- [ ] 下午：开始准备大规模评估对抗样本\n- [ ] 调研数据集\n- [ ] 调研特征集，特征提取器\n         - CIC-Flowmeter\n- [ ] 调研目标模型\n- [ ] 调研攻击方法\n- [ ] 晚上：继续下午的工作，另外刷题别忘了\n\n---\n\n- 6月21日工作计划\n- [x] 上午: 刷题(5-10道题)完成\n      - 3无重复字符的最长子串：滑动串口方法华为medium\n      - 739[每日温度](https://leetcode-cn.com/problems/daily-temperatures)： 华为medium\n         - 暴力破解：使用两个循环往后搜索第一个超过当前温度的日期，算法复杂度为![](https://cdn.nlark.com/yuque/__latex/b67c3aca1bcc34aec861fef4fbf09535.svg#card=math&code=n%5E2&id=yZhEh) 超时\n         - 单调栈：单调栈在普通栈的基础上，限制栈内元素必须有序，按照某种特性(元素的值或者其他属性)单调递增或者单调递减。那么这个题就可以使用单调栈来解决。从前往后遍历每个温度，如果栈不为空并且当前文档大于栈顶那天的温度，说明找到了第一个大于栈顶温度的那边。那么栈顶那天的升温天数为遍历index减去栈顶索引。这个步骤一直进行下去到栈为空，再把当前天压入栈。如果当前温度小于或等于栈顶温度，那么直接压入栈。所以这个里面单调栈中存储的是还没有找到升温天数的索引。AC\n      - 42接雨水: hard\n         - 暴力破解：从左往右遍历每个柱子(第一个O(n))，对于每个柱子，找到他左边最高的柱子，l和右边最高的柱子r。这样当前柱子接雨水的量为min(l, r) - cur。在找左右最高的时候又经历了一个O(n)，所以算法复杂度为O(![](https://cdn.nlark.com/yuque/__latex/b67c3aca1bcc34aec861fef4fbf09535.svg#card=math&code=n%5E2&id=lmO5K))。超时\n         - 单调栈：维护一个单调递减栈，用于存储还没有计算能存储多少雨水的柱子。当新的柱子高度小于栈顶的时候或者栈为空的时候，直接入栈。否则弹出栈顶元素cur，然后比较取柱子高度height[i]和新的栈顶柱子高度height[stack[-1]]的较小值，减去height[cur]的高度就是cur这次存储雨水的高度。然后用i减去stack[-1]再减一就是存储雨水的宽度。高度乘以宽度就是cur柱子存储雨水的量。累加到result里面即可，整体算法复杂度为![](https://cdn.nlark.com/yuque/__latex/e65a67ac353abeeff44c359310d05c02.svg#card=math&code=O%28n%29&id=O2ftM)。AC\n```python\nclass Solution:\n    """\n    这个题要注意是先出栈，然后\n    """\n    def trap(self, height: List[int]) -> int:\n        result = 0\n        stack = []\n        for i in range(len(height)):\n            while len(stack) > 0 and height[i] > height[stack[-1]]:\n                cur = stack[-1]\n                stack = stack[:-1]\n                if len(stack) == 0:\n                    break\n                result += (min(height[stack[-1]], height[i]) - height[cur]) * (i - stack[-1] - 1)\n            stack.append(i)\n        return result\n```\n\n      - 84柱状图中最大的矩形hard\n         - 暴力破解：从左往右遍历所柱形，对于每个柱子，往左和往右找到不小于该柱子高度的左右边界l和r，然后(r - l) * height[i]就是当前柱子能找到的最大矩形面积。算法复杂度是![](https://cdn.nlark.com/yuque/__latex/c120209360617f2e6d2db673c7053248.svg#card=math&code=O%28n%29%5E2&id=PnZuH)超时\n         - 单调栈：同暴力破解。对于每个柱子还是需要找到左右边界。但是使用一个单调递增栈存储还没有找到右边界的柱子。从左往右遍历所有柱子的时候，当单调栈为空或者当前柱子大于栈顶柱子的高度的时候直接入栈。否则弹出栈顶柱子h。计算以h为高度的矩形的最大面积。左边界就是弹出之后的栈顶柱子的索引，右边界就是此时的i，所以宽度为i - stack[-1] - 1, 高度为heights[h], 得到矩形面积后如果大于res则更新resAC\n```python\nclass Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        heights = [0] + heights + [0]\n        stack = []\n        res = 0\n        for i in range(len(heights)):\n            while len(stack) > 0 and heights[i] < heights[stack[-1]]:\n                # print(stack)\n                h = stack.pop()\n                res = max(heights[h] * (i - stack[-1] - 1), res)\n            stack.append(i)\n        return res        \n```\n\n      - 496. 下一个更大元素 Ieasy\n         - 暴力破解：直接两个循环找到num2的下一个更大元素列表。复杂度![](https://cdn.nlark.com/yuque/__latex/f2d5f588234eb61a559ff90c41511b85.svg#card=math&code=O%28n%5E2%29&id=d3jvn)\n         - 单调递减栈：维护一个单调递减栈，用于记录还没有找到下一个更大元素的数。当有元素大于栈顶元素，更新栈顶元素的下一个更大元素位置数组。AC\n```python\nclass Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        nextBig = [-1] * len(nums2)\n        stack = []\n        for i in range(len(nums2)):\n            while len(stack) > 0 and nums2[i] > nums2[stack[-1]]:\n                nextBig[stack[-1]] = nums2[i]\n                stack.pop()\n            stack.append(i)\n        result = [nextBig[nums2.index(x)] for x in nums1 ]\n        return result\n```\n\n- [ ] 下午：~~整理面试的相关资料~~未完成\n- [x] 晚上：开始做实验，基础对抗性评估。从准备数据集和目标模型开始准备部分完成\n      - 准备好KDD_feature_extractor工具\n      - 准备好CICFlowMeter工具用于提取特征\n\n- 6月22日工作计划\n- [x] 上午：找到CICFlowMeter工具的bug并修复完成\n      - ./gradlew distZip官方给的代码之后需要修改生成build文件中的cfm脚本\n```python\nDEFAULT_JVM_OPTS=\'"-Djava.library.path=/home/sunhanwu/tools/CICFlowMeter/jnetpcap/linux/jnetpcap-1.4.r1425/"\'\n```\n\n- [ ] 下午：刷题5-10道华为完成\n      - 15[三数之和](https://leetcode-cn.com/problems/3sum)华为medium\n         - 暴力破解：首先需要给nums排序，用python内置的排序函数，复杂度在![](https://cdn.nlark.com/yuque/__latex/87ca12656f09824e20f4d5cf4c7d126a.svg#card=math&code=O%28log%28n%29%29&id=eOd0d)。然后从左往右遍历nums，对于nums[i], 如果大于0,直接返回。l=i+1，r=n-1,如果nums[i] + nums[l] + nums[r] == 0, 加入到结果列表中，并l ++, r--.(注意结果的去重，可以将列表字符串化进行去重)。如果nums[i] + nums[l] + nums[r]  > 0, r--; 否则 l++AC\n      - [554砖墙](https://leetcode-cn.com/problems/brick-wall) 华为medium\n         - 暴力破解：转换一下思路，找穿过砖块最少的线相当于找空隙最多的线。所以找里面空隙最多的地方划线即可。所以遍历整个wall，找到每行的空隙。然后将空隙出现的次数存储在字典中。最后找到空隙最多的那个。如果字典中没有值的话直接返回len(wall), 否则返回len(wall)减去最多的空隙的个数AC\n      -  medium\n         - 暴力破解：首先按照每个区间的左边界为key对所有区间进行排序。然后循环遍历所有区间。比较当前区间的左边界和上一个区间的右边界。如果当前区间的左边界大于上一个区间的右边界，则不用合并，直接加入到区间中。如果当前区间的左边界小于等于上一个区间的右边界，则需要合并当前区间和上一个区间。注意合并后的区间左边界肯定是上一个区间的左边界，但是右边界是当前区间的右边界和上一个区间的右边界的较大值(需要用max函数取一下较大值)。AC\n      - [53最大子序和](https://leetcode-cn.com/problems/maximum-subarray)华为easy\n         - 贪心解法：初始化res为空列表。遍历数组，如果res的和小于0，则清空res，每次遍历都将nums[i]加入到res中。然后在对比maxNum是否有变化，如果最大值变化了就更新。需要注意的是res只是为了方便理解。实际操作的时候世界用个变量累计和就可以。不然的话sum求和的话会导致复杂度升级为![](https://cdn.nlark.com/yuque/__latex/f2d5f588234eb61a559ff90c41511b85.svg#card=math&code=O%28n%5E2%29&id=zldIr)AC\n      - [20有效的括号](https://leetcode-cn.com/problems/valid-parentheses)华为easy\n         - 简单的使用栈进行匹配AC\n- [ ] 晚上：开始准备跑实验，处理MTA，CIC的三个数据集的数据为KDD特征集和CICFlowMeter特征集，注意打标签未完成\n      - kdd_features:\n- [ ] baseline: KDD99\n- [ ] MTA\n- [ ] CIC\n- [ ] CTU\n      - cicflowmeter_features:\n- [ ] MTA\n- [ ] CIC\n- [ ] CTU\n> 算法题大概完成了5道，但是基本每道题都是查看了解答的。虽然也学到了不少的东西。感觉是目前还是题目刷少了，很多东西想不过来。另外实验部分感觉效率太低。一晚上没有写完一个特征提取模块。\n> \n\n\n---\n\n- 6月23日\n- [ ] 下午：算法题未完成\n      - [5最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring)华为medium\n         -  暴力解法: 首先外部两层循环用于确定子串的左右边界。再一层循环用于判断子串是否是回文串。算法复杂度为![](https://cdn.nlark.com/yuque/__latex/a77815a52a2d0050828079fb142b1410.svg#card=math&code=O%28n%5E3%29&id=VKw30)超时(1000个用例长度一般要求复杂度在![](https://cdn.nlark.com/yuque/__latex/f2d5f588234eb61a559ff90c41511b85.svg#card=math&code=O%28n%5E2%29&id=j3Zdy)）其实如果用java或者c写的话暴力应该能过。\n         - 动态规划：还没有成功实现。部分完成\n      - <br />\n      - <br />\n- [ ] 晚上：~~实验部分~~未完成\n- [ ] options：~~看一篇论文，或者看几个算法视频~~\n> 总结：下午开始做最长回文子串，但是目前没有AC，DP的转态转移方程大概能够理解，但是有些细节问题没有想清楚，导致一直有测试样例没有通过。下午帮帮解决了Pcap++和tstat的问题，发现tstat也提供了一个不错的特征集。另外第一次知道了flowcontainer，有空的话可以仔细了解一下。但是目前的重点还是刷题，学位论文的实验暂缓一下。\n\n\n---\n\n- 6月24日\n- [ ] 上下午：继续刷算法题(动态规划专题)标签\n      - [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring)华为medium\n         - 动态规划：看s[i:j]是否是回文字符串，如果s[i] == s[j] 并且s[i+1:j-1]也是回文字符串的话，s[i:j]就是回文字符串。所有单个字符都是回文字符串，两个一样的字符串也是回文字符串。这样三个以上字符串就可以从简单的较短的字符串推导而来。算法复杂度为O(n)。注意状态转移的时候要先计算长度短的回文字符串，所以循环遍历的时候要遍历长度。而不是回文字符串的左右边界。AC\n      - [227. 基本计算器 II](https://leetcode-cn.com/problems/basic-calculator-ii)华为medium\n         - 使用栈：O(n)一个循环，注意+直接入栈，-将对应的数字的相反数入栈，乘除法需要取出栈顶的元素进行乘除操作之后再入栈。另外注意python中-3//2 = -2，整除去向下取整的。AC\n      - [316. 去除重复字母](https://leetcode-cn.com/problems/remove-duplicate-letters)华为medium\n         - 单调栈：设置一个升序单调栈，当有字符不满足升序的时候。如果后面的字符串中还有栈顶字符，就弹出栈顶。知道栈顶没有出现在后续字符中就压入当前字符入栈。AC\n      - [735. 行星碰撞](https://leetcode-cn.com/problems/asteroid-collision)华为medium\n         - 栈：逻辑判断稍微有点多，需要仔细判断AC\n      - [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix)华为medium\n         - 直接暴力的方法。O(mn)AC\n      - [剑指 Offer 10- II. 青蛙跳台](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof)华为easy\n         - 动态规划，简单题AC\n      - [820. 单词的压缩编码](https://leetcode-cn.com/problems/short-encoding-of-words)\n         - 暴力解法：第一层循环用来遍历单词，里面再有一层循环用来检查之后是否有更合适的单词AC\n      - [46. 全排列](https://leetcode-cn.com/problems/permutations)华为medium\n         - 使用递归，一遍过AC\n      - [1004. 最大连续1的个数 III](https://leetcode-cn.com/problems/max-consecutive-ones-iii)\n         - 暴力破解：理论上的算法复杂度在O(nk!)，并且比较难实现。没有具体去实现\n         - 滑动窗口：抓住一个条件就是滑动窗口内的0不允许超过k个，一旦超过就减小窗口。这样的算法复杂度在O(n)AC\n      - [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists)\n         - 直接O(m+n)暴力求解\n- [ ] 晚上：做实验未完成\n      - 简单的整理了一些数据集和特征集\n:::info\nPS：刷算法题的时候，写完之后除了测试题目提供的几个测试样例，自己也要多测试几个测试样例\n:::\n\n---\n\n- 6月25日\n- [ ] 上午：算法题标签\n      - [994. 腐烂的橘子](https://leetcode-cn.com/problems/rotting-oranges)华为medium\n         - 直接暴力破解：AC\n      - [93. 复原IP地址](https://leetcode-cn.com/problems/restore-ip-addresses) 华为medium\n         - 动态规划：注意出口条件，需要注意加一个控制分割点的参数kAC\n      - [315. 计算右侧小于当前元](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self)未完成\n         - 暴力解法：![](https://cdn.nlark.com/yuque/__latex/f2d5f588234eb61a559ff90c41511b85.svg#card=math&code=O%28n%5E2%29&id=Z7Wbm)超时\n      - [剑指Offer51：数组中的逆序对](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)未完成\n         - <br />\n      - dasjk\n- [ ] 下午：~~算法题~~未完成\n- [ ] 晚上：~~实验~~未完成\n> 腐烂的桔子类似之前螺旋找数一样，没有太深的技巧。然后复原IP地址类似之前的全排列，用递归做，但是注意出口条件就可以了。另外变天大部分时间都没啥效率，在等论文结果。\n\n\n---\n\n- 6月26日\n\n- [ ] 下午：~~整理简历~~未完成\n      - [<br />](https://www.yuque.com/sunhanwu/cwfdgn/yr4wro#nRw73)\n- [ ] 晚上：~~继续整理简历，有空余时间把周六没有完成的两道题做完~~未完成\n> 摆烂的一天\n\n\n---\n\n- 6月27日\n- [ ] 上午：leetcode刷题标签\n- [ ] 下午：完成个人简历中英文版本标签\n- [ ] 晚上：开始考虑投递个人简历标签\n> 初步确定找安全算法方向的工作(类似风控，云安全算法这种)，就硬卷\n\n\ndsa\n<a name="XikjS"></a>\n### todo:\n\n- [ ] 把个人博客给搭建起来，哪怕需要备案，方便做简历\n- [ ] 抽空是几个工作找的不错的师兄们聊聊找工作的事情\n- [ ] 7月之前如果论文中了的话抽一天时间把简历做了\n- [ ] flowcontainer使用\n- [ ] tstat使用\n\n',
    'body_html': '<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u1a9e1a4a"><span class="ne-text">6月5日工作计划</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-tl"><li checked="true" id="u39cf6b7b"><span class="ne-text">下午：sjr课程</span><span data-color="2" id="nkgnt" class="ne-label">完成</span></li><li id="udabfb0c9"><span class="ne-text">下午：完成3-5道leetcode题，继续二分法</span><span data-color="0" id="kEc3s" class="ne-label">未完成</span></li><li id="u3bcd51a0"><span class="ne-text">晚上：调研现有的工作</span><span data-color="0" id="DYerE" class="ne-label">未完成</span></li></ul></ul><p id="u1cccfe53" class="ne-p" style="text-indent: 2em"><span class="ne-text">总结：基本一天没有怎么学习。除了下午学习了一点vue和nodejs的知识外，没有学太多的东西。调研工作没有开展，另外leetcode题并没有开始刷。从明天开始要认真学习。另外，多多少少需要继续完成apphub的编写，keep learning</span></p><p id="u61cc3671" class="ne-p" style="text-indent: 2em"><span class="ne-text"></span></p><ul class="ne-ul"><li id="u5d3141bf"><span class="ne-text">6月6日工作计划</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-tl"><li checked="true" id="u85448b16"><span class="ne-text">下午：搭建登录页面</span><span data-color="2" id="DTpn7" class="ne-label">完成</span></li><li id="u9205a75e"><span class="ne-text" style="text-decoration: line-through">晚上：刷题</span><span data-color="0" id="r1Ang" class="ne-label">未完成</span></li><li id="u931d8609"><span class="ne-text" style="text-decoration: line-through">晚上：科研工作</span><span data-color="0" id="yoMTG" class="ne-label">未完成</span></li></ul></ul><ul class="ne-ul"><li id="ucf758094"><span class="ne-text">6月9日工作计划</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-tl"><li id="u05b5c565"><span class="ne-text">下午：开始准备大规模评估对抗样本</span></li></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-tl"><li id="ua6973bb2"><span class="ne-text">调研数据集</span></li><li id="u46e1af4a"><span class="ne-text">调研特征集，特征提取器</span></li></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="3" class="ne-ul"><li id="u68255eda"><span class="ne-text">CIC-Flowmeter</span></li></ul></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-tl"><li id="u7b098954"><span class="ne-text">调研目标模型</span></li><li id="ua6be137a"><span class="ne-text">调研攻击方法</span></li></ul></ul></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-tl"><li id="uc6eb7596"><span class="ne-text">晚上：继续下午的工作，另外刷题别忘了</span></li></ul></ul><hr id="YJ75A" class="ne-hr"><ul class="ne-ul"><li id="ud5c414f0"><span class="ne-text">6月21日工作计划</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-tl"><li checked="true" id="u62d070a3"><span class="ne-text">上午: 刷题(5-10道题)</span><span data-color="2" id="ORiQc" class="ne-label">完成</span></li></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="udd3dabab"><span class="ne-text">3无重复字符的最长子串：滑动串口方法</span><span data-color="4" id="sEwwY" class="ne-label">华为</span><span data-color="4" id="JoLB6" class="ne-label">medium</span></li><li id="u43df42f5"><span class="ne-text">739</span><a href="https://leetcode-cn.com/problems/daily-temperatures" data-href="https://leetcode-cn.com/problems/daily-temperatures" target="_blank" class="ne-link"><span class="ne-text">每日温度</span></a><span class="ne-text">： </span><span data-color="4" id="R3cDo" class="ne-label">华为</span><span data-color="4" id="eCDJa" class="ne-label">medium</span></li></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="3" class="ne-ul"><li id="u689b5bc5"><span class="ne-text">暴力破解：使用两个循环往后搜索第一个超过当前温度的日期，算法复杂度为</span><span id="yZhEh" class="ne-math"><img src="https://cdn.nlark.com/yuque/__latex/b67c3aca1bcc34aec861fef4fbf09535.svg"></span><span class="ne-text"> </span><span data-color="0" id="Se9jK" class="ne-label">超时</span></li><li id="u1bf4bb23"><span class="ne-text">单调栈：单调栈在普通栈的基础上，限制栈内元素必须有序，按照某种特性(元素的值或者其他属性)单调递增或者单调递减。那么这个题就可以使用单调栈来解决。从前往后遍历每个温度，如果栈不为空并且当前文档大于栈顶那天的温度，说明找到了第一个大于栈顶温度的那边。那么栈顶那天的升温天数为遍历index减去栈顶索引。这个步骤一直进行下去到栈为空，再把当前天压入栈。如果当前温度小于或等于栈顶温度，那么直接压入栈。所以这个里面单调栈中存储的是还没有找到升温天数的索引。</span><span data-color="2" id="xCi08" class="ne-label">AC</span></li></ul></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="ucc8d8e81"><span class="ne-text">42接雨水: </span><span data-color="4" id="MZSJ9" class="ne-label">hard</span></li></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="3" class="ne-ul"><li id="u7d33393e"><span class="ne-text">暴力破解：从左往右遍历每个柱子(第一个O(n))，对于每个柱子，找到他左边最高的柱子，l和右边最高的柱子r。这样当前柱子接雨水的量为min(l, r) - cur。在找左右最高的时候又经历了一个O(n)，所以算法复杂度为O(</span><span id="lmO5K" class="ne-math"><img src="https://cdn.nlark.com/yuque/__latex/b67c3aca1bcc34aec861fef4fbf09535.svg"></span><span class="ne-text">)。</span><span data-color="0" id="tblcu" class="ne-label">超时</span></li><li id="u237ada64"><span class="ne-text">单调栈：维护一个单调递减栈，用于存储还没有计算能存储多少雨水的柱子。当新的柱子高度小于栈顶的时候或者栈为空的时候，直接入栈。否则弹出栈顶元素cur，然后比较取柱子高度height[i]和新的栈顶柱子高度height[stack[-1]]的较小值，减去height[cur]的高度就是cur这次存储雨水的高度。然后用i减去stack[-1]再减一就是存储雨水的宽度。高度乘以宽度就是cur柱子存储雨水的量。累加到result里面即可，整体算法复杂度为</span><span id="O2ftM" class="ne-math"><img src="https://cdn.nlark.com/yuque/__latex/e65a67ac353abeeff44c359310d05c02.svg"></span><span class="ne-text">。</span><span data-color="2" id="qFSCl" class="ne-label">AC</span></li></ul></ul></ul></ul><pre data-language="python" id="J3KPG" class="ne-codeblock language-python">class Solution:\n    &quot;&quot;&quot;\n    这个题要注意是先出栈，然后\n    &quot;&quot;&quot;\n    def trap(self, height: List[int]) -&gt; int:\n        result = 0\n        stack = []\n        for i in range(len(height)):\n            while len(stack) &gt; 0 and height[i] &gt; height[stack[-1]]:\n                cur = stack[-1]\n                stack = stack[:-1]\n                if len(stack) == 0:\n                    break\n                result += (min(height[stack[-1]], height[i]) - height[cur]) * (i - stack[-1] - 1)\n            stack.append(i)\n        return result</pre><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="u860c090f"><span class="ne-text">84柱状图中最大的矩形</span><span data-color="4" id="DcCKq" class="ne-label">hard</span></li></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="3" class="ne-ul"><li id="u3383701a"><span class="ne-text">暴力破解：从左往右遍历所柱形，对于每个柱子，往左和往右找到不小于该柱子高度的左右边界l和r，然后(r - l) * height[i]就是当前柱子能找到的最大矩形面积。算法复杂度是</span><span id="PnZuH" class="ne-math"><img src="https://cdn.nlark.com/yuque/__latex/c120209360617f2e6d2db673c7053248.svg"></span><span data-color="0" id="k1gDZ" class="ne-label">超时</span></li><li id="u46872800"><span class="ne-text">单调栈：同暴力破解。对于每个柱子还是需要找到左右边界。但是使用一个单调递增栈存储还没有找到右边界的柱子。从左往右遍历所有柱子的时候，当单调栈为空或者当前柱子大于栈顶柱子的高度的时候直接入栈。否则弹出栈顶柱子h。计算以h为高度的矩形的最大面积。左边界就是弹出之后的栈顶柱子的索引，右边界就是此时的i，所以宽度为i - stack[-1] - 1, 高度为heights[h], 得到矩形面积后如果大于res则更新res</span><span data-color="2" id="fpUF9" class="ne-label">AC</span></li></ul></ul></ul></ul><pre data-language="python" id="BDkm8" class="ne-codeblock language-python">class Solution:\n    def largestRectangleArea(self, heights: List[int]) -&gt; int:\n        heights = [0] + heights + [0]\n        stack = []\n        res = 0\n        for i in range(len(heights)):\n            while len(stack) &gt; 0 and heights[i] &lt; heights[stack[-1]]:\n                # print(stack)\n                h = stack.pop()\n                res = max(heights[h] * (i - stack[-1] - 1), res)\n            stack.append(i)\n        return res        </pre><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="ud0013d2b"><span class="ne-text">496. 下一个更大元素 I</span><span data-color="4" id="TDcI1" class="ne-label">easy</span></li></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="3" class="ne-ul"><li id="u644496b2"><span class="ne-text">暴力破解：直接两个循环找到num2的下一个更大元素列表。复杂度</span><span id="d3jvn" class="ne-math"><img src="https://cdn.nlark.com/yuque/__latex/f2d5f588234eb61a559ff90c41511b85.svg"></span></li><li id="u427fef04"><span class="ne-text">单调递减栈：维护一个单调递减栈，用于记录还没有找到下一个更大元素的数。当有元素大于栈顶元素，更新栈顶元素的下一个更大元素位置数组。</span><span data-color="2" id="cqbme" class="ne-label">AC</span></li></ul></ul></ul></ul><pre data-language="python" id="NNlHe" class="ne-codeblock language-python">class Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:\n        nextBig = [-1] * len(nums2)\n        stack = []\n        for i in range(len(nums2)):\n            while len(stack) &gt; 0 and nums2[i] &gt; nums2[stack[-1]]:\n                nextBig[stack[-1]] = nums2[i]\n                stack.pop()\n            stack.append(i)\n        result = [nextBig[nums2.index(x)] for x in nums1 ]\n        return result</pre><ul class="ne-list-wrap"><ul ne-level="1" class="ne-tl"><li id="u5921874c"><span class="ne-text">下午：</span><span class="ne-text" style="text-decoration: line-through">整理面试的相关资料</span><span data-color="0" id="fYUGm" class="ne-label">未完成</span></li><li checked="true" id="u26e8257a"><span class="ne-text">晚上：开始做实验，基础对抗性评估。从准备数据集和目标模型开始准备</span><span data-color="1" id="Mzrn8" class="ne-label">部分完成</span></li></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="u5a6eb8fb"><span class="ne-text">准备好KDD_feature_extractor工具</span></li><li id="uc2020f2e"><span class="ne-text">准备好CICFlowMeter工具用于提取特征</span></li></ul></ul></ul><p id="u2a5e840d" class="ne-p"><br></p><ul class="ne-ul"><li id="ub8e67b8c"><span class="ne-text">6月22日工作计划</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-tl"><li checked="true" id="ua8def9b7"><span class="ne-text">上午：找到CICFlowMeter工具的bug并修复</span><span data-color="2" id="PylZ6" class="ne-label">完成</span></li></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="u13d4a236"><span class="ne-text">./gradlew distZip官方给的代码之后需要修改生成build文件中的cfm脚本</span></li></ul></ul></ul><pre data-language="python" id="A8LhD" class="ne-codeblock language-python">DEFAULT_JVM_OPTS=\'&quot;-Djava.library.path=/home/sunhanwu/tools/CICFlowMeter/jnetpcap/linux/jnetpcap-1.4.r1425/&quot;\'</pre><ul class="ne-list-wrap"><ul ne-level="1" class="ne-tl"><li id="ua8910010"><span class="ne-text">下午：刷题5-10道华为</span><span data-color="2" id="sDnUU" class="ne-label">完成</span></li></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="u2b57954a"><span class="ne-text">15</span><a href="https://leetcode-cn.com/problems/3sum" data-href="https://leetcode-cn.com/problems/3sum" target="_blank" class="ne-link"><span class="ne-text">三数之和</span></a><span data-color="4" id="xmKB2" class="ne-label">华为</span><span data-color="4" id="gzDrE" class="ne-label">medium</span></li></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="3" class="ne-ul"><li id="u639068d1"><span class="ne-text">暴力破解：首先需要给nums排序，用python内置的排序函数，复杂度在</span><span id="eOd0d" class="ne-math"><img src="https://cdn.nlark.com/yuque/__latex/87ca12656f09824e20f4d5cf4c7d126a.svg"></span><span class="ne-text">。然后从左往右遍历nums，对于nums[i], 如果大于0,直接返回。l=i+1，r=n-1,如果nums[i] + nums[l] + nums[r] == 0, 加入到结果列表中，并l ++, r--.(注意结果的去重，可以将列表字符串化进行去重)。如果nums[i] + nums[l] + nums[r]  &gt; 0, r--; 否则 l++</span><span data-color="2" id="mzaLg" class="ne-label">AC</span></li></ul></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="u9b113c57"><a href="https://leetcode-cn.com/problems/brick-wall" data-href="https://leetcode-cn.com/problems/brick-wall" target="_blank" class="ne-link"><span class="ne-text">554砖墙</span></a><span class="ne-text"> </span><span data-color="4" id="vlUh6" class="ne-label">华为</span><span data-color="4" id="KpzZW" class="ne-label">medium</span></li></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="3" class="ne-ul"><li id="u42f07272"><span class="ne-text">暴力破解：转换一下思路，找穿过砖块最少的线相当于找空隙最多的线。所以找里面空隙最多的地方划线即可。所以遍历整个wall，找到每行的空隙。然后将空隙出现的次数存储在字典中。最后找到空隙最多的那个。如果字典中没有值的话直接返回len(wall), 否则返回len(wall)减去最多的空隙的个数</span><span data-color="2" id="wsOEn" class="ne-label">AC</span></li></ul></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="u129f0714"><span class="ne-text"> </span><span data-color="4" id="ScCd5" class="ne-label">medium</span></li></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="3" class="ne-ul"><li id="u97e3c74d"><span class="ne-text">暴力破解：首先按照每个区间的左边界为key对所有区间进行排序。然后循环遍历所有区间。比较当前区间的左边界和上一个区间的右边界。如果当前区间的左边界大于上一个区间的右边界，则不用合并，直接加入到区间中。如果当前区间的左边界小于等于上一个区间的右边界，则需要合并当前区间和上一个区间。注意合并后的区间左边界肯定是上一个区间的左边界，但是右边界是当前区间的右边界和上一个区间的右边界的较大值(需要用max函数取一下较大值)。</span><span data-color="2" id="WS4u9" class="ne-label">AC</span></li></ul></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="u011803bf"><a href="https://leetcode-cn.com/problems/maximum-subarray" data-href="https://leetcode-cn.com/problems/maximum-subarray" target="_blank" class="ne-link"><span class="ne-text">53最大子序和</span></a><span data-color="4" id="Ci8Mg" class="ne-label">华为</span><span data-color="4" id="Y8vNR" class="ne-label">easy</span></li></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="3" class="ne-ul"><li id="u47899a55"><span class="ne-text">贪心解法：初始化res为空列表。遍历数组，如果res的和小于0，则清空res，每次遍历都将nums[i]加入到res中。然后在对比maxNum是否有变化，如果最大值变化了就更新。需要注意的是res只是为了方便理解。实际操作的时候世界用个变量累计和就可以。不然的话sum求和的话会导致复杂度升级为</span><span id="zldIr" class="ne-math"><img src="https://cdn.nlark.com/yuque/__latex/f2d5f588234eb61a559ff90c41511b85.svg"></span><span data-color="2" id="RmKbP" class="ne-label">AC</span></li></ul></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="ud615e761"><a href="https://leetcode-cn.com/problems/valid-parentheses" data-href="https://leetcode-cn.com/problems/valid-parentheses" target="_blank" class="ne-link"><span class="ne-text">20有效的括号</span></a><span data-color="4" id="yVtDJ" class="ne-label">华为</span><span data-color="4" id="rbkqf" class="ne-label">easy</span></li></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="3" class="ne-ul"><li id="uf3b9f277"><span class="ne-text">简单的使用栈进行匹配</span><span data-color="2" id="J7m9m" class="ne-label">AC</span></li></ul></ul></ul></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-tl"><li id="uf9f1d9af"><span class="ne-text">晚上：开始准备跑实验，处理MTA，CIC的三个数据集的数据为KDD特征集和CICFlowMeter特征集，注意打标签</span><span data-color="0" id="k7bFe" class="ne-label">未完成</span></li></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="u6c3f5586"><span class="ne-text">kdd_features:</span></li></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="3" class="ne-tl"><li id="ue0f8ac48"><span class="ne-text">baseline: KDD99</span></li><li id="ufe988a40"><span class="ne-text">MTA</span></li><li id="u80b8e4f5"><span class="ne-text">CIC</span></li><li id="u10c0ddfa"><span class="ne-text">CTU</span></li></ul></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="uc5d008e5"><span class="ne-text">cicflowmeter_features:</span></li></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="3" class="ne-tl"><li id="ua4105f53"><span class="ne-text">MTA</span></li><li id="u98be61ee"><span class="ne-text">CIC</span></li><li id="u2fa6d964"><span class="ne-text">CTU</span></li></ul></ul></ul></ul><div class="ne-quote"><p id="u63012ef7" class="ne-p" style="text-indent: 2em; margin-left: 2em"><span class="ne-text">算法题大概完成了5道，但是基本每道题都是查看了解答的。虽然也学到了不少的东西。感觉是目前还是题目刷少了，很多东西想不过来。另外实验部分感觉效率太低。一晚上没有写完一个特征提取模块。</span></p><p id="uf0ad91fa" class="ne-p" style="text-indent: 2em; margin-left: 2em"><span class="ne-text"></span></p></div><hr id="uSuRy" class="ne-hr"><ul class="ne-ul"><li id="uf3dc6d96"><span class="ne-text">6月23日</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-tl"><li id="u550ff82b"><span class="ne-text">下午：算法题</span><span data-color="0" id="EQddY" class="ne-label">未完成</span></li></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="u48fb27bc"><a href="https://leetcode-cn.com/problems/longest-palindromic-substring" data-href="https://leetcode-cn.com/problems/longest-palindromic-substring" target="_blank" class="ne-link"><span class="ne-text">5最长回文子串</span></a><span data-color="4" id="yi8cR" class="ne-label">华为</span><span data-color="4" id="urHtb" class="ne-label">medium</span></li></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="3" class="ne-ul"><li id="u4e52a1f3"><span class="ne-text"> 暴力解法: 首先外部两层循环用于确定子串的左右边界。再一层循环用于判断子串是否是回文串。算法复杂度为</span><span id="VKw30" class="ne-math"><img src="https://cdn.nlark.com/yuque/__latex/a77815a52a2d0050828079fb142b1410.svg"></span><span data-color="0" id="frtHh" class="ne-label">超时</span><span class="ne-text">(1000个用例长度一般要求复杂度在</span><span id="j3Zdy" class="ne-math"><img src="https://cdn.nlark.com/yuque/__latex/f2d5f588234eb61a559ff90c41511b85.svg"></span><span class="ne-text">）其实如果用java或者c写的话暴力应该能过。</span></li><li id="u32c2f070"><span class="ne-text">动态规划：还没有成功实现。</span><span data-color="1" id="xFgGy" class="ne-label">部分完成</span></li></ul></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="u77881b7b"><span class="ne-text"></span></li><li id="u8b884fc3"><span class="ne-text"></span></li></ul></ul></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-tl"><li id="ua721c60e"><span class="ne-text">晚上：</span><span class="ne-text" style="text-decoration: line-through">实验部分</span><span data-color="0" id="oCRvz" class="ne-label">未完成</span></li><li id="ufd8e4c5f"><span class="ne-text">options：</span><span class="ne-text" style="text-decoration: line-through">看一篇论文，或者看几个算法视频</span></li></ul></ul><div class="ne-quote"><p id="uea5e5bb4" class="ne-p"><span class="ne-text">总结：下午开始做最长回文子串，但是目前没有AC，DP的转态转移方程大概能够理解，但是有些细节问题没有想清楚，导致一直有测试样例没有通过。下午帮帮解决了Pcap++和tstat的问题，发现tstat也提供了一个不错的特征集。另外第一次知道了flowcontainer，有空的话可以仔细了解一下。但是目前的重点还是刷题，学位论文的实验暂缓一下。</span></p></div><hr id="rcEE5" class="ne-hr"><ul class="ne-ul"><li id="u983f0386"><span class="ne-text">6月24日</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-tl"><li id="u15542aef"><span class="ne-text">上下午：继续刷算法题(动态规划专题)</span><span data-color="0" id="cfPAA" class="ne-label">设置标签</span></li></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="ua5670107"><a href="https://leetcode-cn.com/problems/longest-palindromic-substring" data-href="https://leetcode-cn.com/problems/longest-palindromic-substring" target="_blank" class="ne-link"><span class="ne-text">5. 最长回文子串</span></a><span data-color="4" id="IvafT" class="ne-label">华为</span><span data-color="4" id="l1kfp" class="ne-label">medium</span></li></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="3" class="ne-ul"><li id="ub2444372"><span class="ne-text">动态规划：看s[i:j]是否是回文字符串，如果s[i] == s[j] 并且s[i+1:j-1]也是回文字符串的话，s[i:j]就是回文字符串。所有单个字符都是回文字符串，两个一样的字符串也是回文字符串。这样三个以上字符串就可以从简单的较短的字符串推导而来。算法复杂度为O(n)。注意状态转移的时候要先计算长度短的回文字符串，所以循环遍历的时候要遍历长度。而不是回文字符串的左右边界。</span><span data-color="2" id="wmyy9" class="ne-label">AC</span></li></ul></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="ud013098f"><a href="https://leetcode-cn.com/problems/basic-calculator-ii" data-href="https://leetcode-cn.com/problems/basic-calculator-ii" target="_blank" class="ne-link"><span class="ne-text">227. 基本计算器 II</span></a><span data-color="4" id="Dz3nO" class="ne-label">华为</span><span data-color="4" id="A3nWK" class="ne-label">medium</span></li></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="3" class="ne-ul"><li id="ud6b0bf9d"><span class="ne-text">使用栈：O(n)一个循环，注意+直接入栈，-将对应的数字的相反数入栈，乘除法需要取出栈顶的元素进行乘除操作之后再入栈。另外注意python中-3//2 = -2，整除去向下取整的。</span><span data-color="2" id="JVYH6" class="ne-label">AC</span></li></ul></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="u02398a5c"><a href="https://leetcode-cn.com/problems/remove-duplicate-letters" data-href="https://leetcode-cn.com/problems/remove-duplicate-letters" target="_blank" class="ne-link"><span class="ne-text">316. 去除重复字母</span></a><span data-color="4" id="lTv8i" class="ne-label">华为</span><span data-color="4" id="yhcO7" class="ne-label">medium</span></li></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="3" class="ne-ul"><li id="ua55cca9e"><span class="ne-text">单调栈：设置一个升序单调栈，当有字符不满足升序的时候。如果后面的字符串中还有栈顶字符，就弹出栈顶。知道栈顶没有出现在后续字符中就压入当前字符入栈。</span><span data-color="2" id="sZvn3" class="ne-label">AC</span></li></ul></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="ub2adfc85"><a href="https://leetcode-cn.com/problems/asteroid-collision" data-href="https://leetcode-cn.com/problems/asteroid-collision" target="_blank" class="ne-link"><span class="ne-text">735. 行星碰撞</span></a><span data-color="4" id="AK0p1" class="ne-label">华为</span><span data-color="4" id="H0Xyg" class="ne-label">medium</span></li></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="3" class="ne-ul"><li id="u40884e15"><span class="ne-text">栈：逻辑判断稍微有点多，需要仔细判断</span><span data-color="2" id="qBGwp" class="ne-label">AC</span></li></ul></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="u3e4e7693"><a href="https://leetcode-cn.com/problems/spiral-matrix" data-href="https://leetcode-cn.com/problems/spiral-matrix" target="_blank" class="ne-link"><span class="ne-text">54. 螺旋矩阵</span></a><span data-color="4" id="rER5p" class="ne-label">华为</span><span data-color="4" id="PWbBJ" class="ne-label">medium</span></li></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="3" class="ne-ul"><li id="ubc67a76e"><span class="ne-text">直接暴力的方法。O(mn)</span><span data-color="2" id="ONtu1" class="ne-label">AC</span></li></ul></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="u974e09d0"><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof" data-href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof" target="_blank" class="ne-link"><span class="ne-text">剑指 Offer 10- II. 青蛙跳台</span></a><span data-color="4" id="YPDm0" class="ne-label">华为</span><span data-color="4" id="kn2Mo" class="ne-label">easy</span></li></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="3" class="ne-ul"><li id="uf77b843b"><span class="ne-text">动态规划，简单题</span><span data-color="2" id="Dwthc" class="ne-label">AC</span></li></ul></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="u6ca8e5c2"><a href="https://leetcode-cn.com/problems/short-encoding-of-words" data-href="https://leetcode-cn.com/problems/short-encoding-of-words" target="_blank" class="ne-link"><span class="ne-text">820. 单词的压缩编码</span></a></li></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="3" class="ne-ul"><li id="u0ea89dba"><span class="ne-text">暴力解法：第一层循环用来遍历单词，里面再有一层循环用来检查之后是否有更合适的单词</span><span data-color="2" id="OqhGN" class="ne-label">AC</span></li></ul></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="u4be9f0f4"><a href="https://leetcode-cn.com/problems/permutations" data-href="https://leetcode-cn.com/problems/permutations" target="_blank" class="ne-link"><span class="ne-text">46. 全排列</span></a><span data-color="4" id="Ydmzj" class="ne-label">华为</span><span data-color="4" id="hxili" class="ne-label">medium</span></li></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="3" class="ne-ul"><li id="uc916f5df"><span class="ne-text">使用递归，一遍过</span><span data-color="2" id="Gdp6k" class="ne-label">AC</span></li></ul></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="u240c97b1"><a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii" data-href="https://leetcode-cn.com/problems/max-consecutive-ones-iii" target="_blank" class="ne-link"><span class="ne-text">1004. 最大连续1的个数 III</span></a></li></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="3" class="ne-ul"><li id="u8e9e32e0"><span class="ne-text">暴力破解：理论上的算法复杂度在O(nk!)，并且比较难实现。没有具体去实现</span></li><li id="uba22932e"><span class="ne-text">滑动窗口：抓住一个条件就是滑动窗口内的0不允许超过k个，一旦超过就减小窗口。这样的算法复杂度在O(n)</span><span data-color="2" id="w0Zds" class="ne-label">AC</span></li></ul></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="uc9eb4585"><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists" data-href="https://leetcode-cn.com/problems/merge-two-sorted-lists" target="_blank" class="ne-link"><span class="ne-text">21. 合并两个有序链表</span></a></li></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="3" class="ne-ul"><li id="u7d72132a"><span class="ne-text">直接O(m+n)暴力求解</span></li></ul></ul></ul></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-tl"><li id="uec170dfd"><span class="ne-text">晚上：做实验</span><span data-color="0" id="kBwjp" class="ne-label">未完成</span></li></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="u8899f785"><span class="ne-text">简单的整理了一些数据集和特征集</span></li></ul></ul></ul><div data-type="info" class="ne-alert"><p id="u74b8db9b" class="ne-p" style="text-indent: 2em"><span class="ne-text">PS：刷算法题的时候，写完之后除了测试题目提供的几个测试样例，自己也要多测试几个测试样例</span></p></div><hr id="vJtyG" class="ne-hr"><ul class="ne-ul"><li id="uc9757c63"><span class="ne-text">6月25日</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-tl"><li id="u146bffe6"><span class="ne-text">上午：算法题</span><span data-color="0" id="awUlg" class="ne-label">设置标签</span></li></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="ud3a03137"><a href="https://leetcode-cn.com/problems/rotting-oranges" data-href="https://leetcode-cn.com/problems/rotting-oranges" target="_blank" class="ne-link"><span class="ne-text">994. 腐烂的橘子</span></a><span data-color="4" id="M07QJ" class="ne-label">华为</span><span data-color="4" id="vDrGG" class="ne-label">medium</span></li></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="3" class="ne-ul"><li id="u8e03ef66"><span class="ne-text">直接暴力破解：</span><span data-color="2" id="KOCit" class="ne-label">AC</span></li></ul></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="uadfb43ad"><a href="https://leetcode-cn.com/problems/restore-ip-addresses" data-href="https://leetcode-cn.com/problems/restore-ip-addresses" target="_blank" class="ne-link"><span class="ne-text">93. 复原IP地址</span></a><span class="ne-text"> </span><span data-color="4" id="ZDMva" class="ne-label">华为</span><span data-color="4" id="pgvJQ" class="ne-label">medium</span></li></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="3" class="ne-ul"><li id="ub50da8ab"><span class="ne-text">动态规划：注意出口条件，需要注意加一个控制分割点的参数k</span><span data-color="2" id="z1iAq" class="ne-label">AC</span></li></ul></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="ufb3a6992"><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self" data-href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self" target="_blank" class="ne-link"><span class="ne-text">315. 计算右侧小于当前元</span></a><span data-color="0" id="XGpkE" class="ne-label">未完成</span></li></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="3" class="ne-ul"><li id="u80178a6a"><span class="ne-text">暴力解法：</span><span id="Z7Wbm" class="ne-math"><img src="https://cdn.nlark.com/yuque/__latex/f2d5f588234eb61a559ff90c41511b85.svg"></span><span data-color="0" id="HdKZl" class="ne-label">超时</span></li></ul></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="ud39dcb33"><a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" data-href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" class="ne-link"><span class="ne-text">剑指Offer51：数组中的逆序对</span></a><span data-color="0" id="ZjCmd" class="ne-label">未完成</span></li></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="3" class="ne-ul"><li id="ud2c4677a"><span class="ne-text"></span></li></ul></ul></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="ue742bc82"><span class="ne-text">dasjk</span></li></ul></ul></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-tl"><li id="ud471f144"><span class="ne-text">下午：</span><span class="ne-text" style="text-decoration: line-through">算法题</span><span data-color="0" id="NG5Rc" class="ne-label">未完成</span></li><li id="ub2999ec2"><span class="ne-text">晚上：</span><span class="ne-text" style="text-decoration: line-through">实验</span><span data-color="0" id="dhupZ" class="ne-label">未完成</span></li></ul></ul><div class="ne-quote"><p id="ud9499b6b" class="ne-p"><span class="ne-text">腐烂的桔子类似之前螺旋找数一样，没有太深的技巧。然后复原IP地址类似之前的全排列，用递归做，但是注意出口条件就可以了。另外变天大部分时间都没啥效率，在等论文结果。</span></p></div><hr id="dIOyf" class="ne-hr"><ul class="ne-ul"><li id="u47918e61"><span class="ne-text">6月26日</span></li></ul><p id="u4ed56925" class="ne-p"><br></p><ul class="ne-list-wrap"><ul ne-level="1" class="ne-tl"><li id="u40dd3730"><span class="ne-text">下午：</span><span class="ne-text" style="text-decoration: line-through">整理简历</span><span data-color="0" id="TIn43" class="ne-label">未完成</span></li></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="u03859338"><a href="https://www.yuque.com/sunhanwu/cwfdgn/yr4wro#nRw73" data-href="https://www.yuque.com/sunhanwu/cwfdgn/yr4wro#nRw73" class="ne-link"></a></li></ul></ul></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-tl"><li id="u17b81b81"><span class="ne-text">晚上：</span><span class="ne-text" style="text-decoration: line-through">继续整理简历，有空余时间把周六没有完成的两道题做完</span><span data-color="0" id="Mn2tU" class="ne-label">未完成</span></li></ul></ul><div class="ne-quote"><p id="uc3b13370" class="ne-p"><span class="ne-text">摆烂的一天</span></p></div><hr id="ajNu8" class="ne-hr"><ul class="ne-ul"><li id="u6f08d866"><span class="ne-text">6月27日</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-tl"><li id="u3c5d68d0"><span class="ne-text">上午：leetcode刷题</span><span data-color="0" id="IaKC4" class="ne-label">设置标签</span></li><li id="ua5c3ac28"><span class="ne-text">下午：完成个人简历中英文版本</span><span data-color="0" id="mK9lY" class="ne-label">设置标签</span></li><li id="u598bc1ed"><span class="ne-text">晚上：开始考虑投递个人简历</span><span data-color="0" id="ZHOVD" class="ne-label">设置标签</span></li></ul></ul><div class="ne-quote"><p id="ua4c0e85b" class="ne-p"><span class="ne-text">初步确定找安全算法方向的工作(类似风控，云安全算法这种)，就硬卷</span></p></div><p id="uec66a3eb" class="ne-p"><br></p><p id="uee58940f" class="ne-p"><span class="ne-text">dsa</span></p><h3 id="XikjS"><span class="ne-text">todo:</span></h3><ul class="ne-tl"><li id="u253beb49"><span class="ne-text">把个人博客给搭建起来，哪怕需要备案，方便做简历</span></li><li id="u83a867f0"><span class="ne-text">抽空是几个工作找的不错的师兄们聊聊找工作的事情</span></li><li id="udbbe047c"><span class="ne-text">7月之前如果论文中了的话抽一天时间把简历做了</span></li><li id="u7b027916"><span class="ne-text">flowcontainer使用</span></li><li id="u44d3a191"><span class="ne-text">tstat使用</span></li></ul><p id="u3929452b" class="ne-p"><span class="ne-text"></span></p></div>',
    'public': 1,
    'status': 1,
    'view_status': 0,
    'read_status': 1,
    'likes_count': 0,
    'comments_count': 0,
    'content_updated_at': '2022-06-26T16:17:31.000Z',
    'deleted_at': None,
    'created_at': '2022-06-04T12:19:44.000Z',
    'updated_at': '2022-06-26T16:17:31.000Z',
    'published_at': '2022-06-26T16:17:31.000Z',
    'first_published_at': '2022-06-05T19:00:42.929Z',
    'word_count': 3628,
    '_serializer': 'webhook.doc_detail',
    'path': 'sunhanwu/cwfdgn/bg3cg1',
    'publish': False,
    'action_type': 'update',
    'webhook_subject_type': 'update',
    'actor_id': 671301
  }
}
